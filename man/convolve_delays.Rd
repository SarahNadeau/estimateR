% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-convolution.R
\name{convolve_delays}
\alias{convolve_delays}
\title{Convolve delay distributions}
\usage{
convolve_delays(delays, n_report_time_steps = NULL, ...)
}
\arguments{
\item{delays}{List of delays, with flexible structure.
Each delay in the \code{delays} list can be one of:
\itemize{
\item{a list representing a distribution object}
\item{a discretized delay distribution vector}
\item{a discretized delay distribution matrix}
\item{a dataframe containing empirical delay data}
}}

\item{n_report_time_steps}{integer. Length of incidence time series.
Use only when providing empirical delay data.}

\item{...}{
  Arguments passed on to \code{\link[=get_matrix_from_empirical_delay_distr]{get_matrix_from_empirical_delay_distr}}, \code{\link[=build_delay_distribution]{build_delay_distribution}}
  \describe{
    \item{\code{min_number_cases}}{integer.
Minimal number of cases to build the empirical distribution from.
If \code{num_steps_in_a_unit} is \code{NULL}, for any time step T,
the \code{min_number_cases} records prior to T are used.
If less than \code{min_number_cases} delays were recorded before T,
then T is ignored and the \code{min_number_cases} earliest-recorded delays are used.
If \code{num_steps_in_a_unit} is given a value, a similar same procedure is applied,
except that, now at least \code{min_number_cases} must be taken over a round number of
time units. For example, if \code{num_steps_in_a_unit = 7}, and time steps represent consecutive days,
to build the distribution for time step T,
we find the smallest number of weeks starting from T and going in the past,
for which at least \code{min_number_cases} delays were recorded.
We then use all the delays recorded during these weeks.
Weeks are not meant as necessarily being Monday to Sunday,
but simply 7 days in a row, e.g. it can be Thursday-Wednesday.
Again, if less than \code{min_number_cases} delays were recorded before T,
then T is ignored.
We then find the minimum number of weeks, starting from the first recorded delay
that contains at least \code{min_number_cases}.}
    \item{\code{upper_quantile_threshold}}{numeric. Between 0 and 1.
Argument for internal use.}
    \item{\code{min_number_cases_fraction}}{numeric. Between 0 and 1.
If \code{min_number_cases} is not provided (kept to \code{NULL}),
the number of most-recent cases used to build
the instant delay distribution is \code{min_number_cases_fraction}
times the total number of reported delays.}
    \item{\code{min_min_number_cases}}{numeric. Lower bound
for number of cases used to build an instant delay distribution.}
    \item{\code{fit}}{string. One of "gamma" or "none". Specifies the type of fit that
is applied to the columns of the delay matrix}
    \item{\code{num_steps_in_a_unit}}{Optional argument.
Number of time steps in a full time unit (e.g. 7 if looking at weeks).
If set, the delays used to build a particular
delay distribution will span over a round number of such time units.
This option is included for comparison with legacy code.}
    \item{\code{ref_date}}{Date. Optional. Date of the first data entry in \code{incidence_data}}
    \item{\code{time_step}}{string. Time between two consecutive incidence datapoints.
"day", "2 days", "week", "year"... (see \code{\link[base]{seq.Date}} for details)}
    \item{\code{return_fitted_distribution}}{boolean. If TRUE, the function also returns the gamma distribution that was fitted to the respective column.}
    \item{\code{max_quantile}}{numeric value between 0 and 1.
Upper quantile reached by the last element in the discretized distribution vector.}
    \item{\code{offset_by_one}}{boolean.
Set to TRUE if \code{distribution} represents the fit of data that was offset by one
(\code{fitted_data = original_data + 1}) to accommodate zeroes in \code{original_data}.}
  }}
}
\value{
a discretized delay distribution vector or matrix.
A vector is returned when input delay distributions are constant through time:
either they are vectors already or in the form of a list-specified distribution.
A matrix is returned when at least one of the delays has a delay distribution
that can change through time. This is the case with empirical delay data
or if any of the input is already a delay distribution matrix.
}
\description{
Take a list of delay distributions and return their convolution.
The convolution of a delay A -> B and a delay B -> C corresponds to the
delay distribution of A -> C.
Delays are assumed to happen in the same chronological order as the order
they are given in in the \code{delays} list.
}
\details{
This function is flexible in the type of delay inputs it can handle.
Each delay in the \code{delays} list can be one of:
\itemize{
\item{a list representing a distribution object}
\item{a discretized delay distribution vector}
\item{a discretized delay distribution matrix}
\item{a dataframe containing empirical delay data}
}

see \code{\link{get_matrix_from_empirical_delay_distr}} for details on the format
expected for the empirical delay data.
}
